#include <boost/beast/core.hpp>
#include <boost/beast/websocket.hpp>
#include <boost/asio/dispatch.hpp>
#include <boost/asio/strand.hpp>
#include <boost/asio/ip/tcp.hpp>
#include <nlohmann/json.hpp>
#include <iostream>
#include <string>
#include <vector>
#include <memory>
#include <map>
#include <mutex>
#include <thread>
#include <atomic>
#include <queue>
#include <chrono>

namespace beast = boost::beast;
namespace http = beast::http;
namespace websocket = beast::websocket;
namespace net = boost::asio;
using tcp = boost::asio::ip::tcp;
using json = nlohmann::json;

class ChessGame {
private:
    std::vector<std::vector<std::string>> board;
    std::string currentPlayer;
    bool gameActive;
    std::string gameResult;

    float white_time_seconds_;
    float black_time_seconds_;
    std::chrono::steady_clock::time_point last_move_time_;
    bool first_move_made_;

public:
    ChessGame() {
        resetBoard();
    }

    void resetBoard() {
        board = {
            {"r", "n", "b", "q", "k", "b", "n", "r"},
            {"p", "p", "p", "p", "p", "p", "p", "p"},
            {"", "", "", "", "", "", "", ""},
            {"", "", "", "", "", "", "", ""},
            {"", "", "", "", "", "", "", ""},
            {"", "", "", "", "", "", "", ""},
            {"P", "P", "P", "P", "P", "P", "P", "P"},
            {"R", "N", "B", "Q", "K", "B", "N", "R"}
        };
        currentPlayer = "white";
        gameActive = true;
        gameResult = "";

        white_time_seconds_ = 300.0f; // 5 minutes
        black_time_seconds_ = 300.0f;
        last_move_time_ = std::chrono::steady_clock::now();
        first_move_made_ = false;
    }

    json getBoardState() {
        json state;
        state["board"] = board; // Keep for backward compatibility or other uses
        state["currentPlayer"] = currentPlayer; // Keep for backward compatibility or other uses
        state["gameActive"] = gameActive;
        state["gameResult"] = gameResult;
        state["whiteTime"] = white_time_seconds_;
        state["blackTime"] = black_time_seconds_;
        state["fen"] = toFen(); // Add the FEN string
        return state;
    }

    bool makeMove(int fromRow, int fromCol, int toRow, int toCol) {
        if (!gameActive) return false;

        if (fromRow < 0 || fromRow >= 8 || fromCol < 0 || fromCol >= 8) return false;
        if (toRow < 0 || toRow >= 8 || toCol < 0 || toCol >= 8) return false;

        std::string piece = board[fromRow][fromCol];
        if (piece.empty()) return false;

        // Simple validation: white pieces are uppercase, black are lowercase
        bool isWhitePiece = (piece[0] >= 'A' && piece[0] <= 'Z');
        if ((currentPlayer == "white" && !isWhitePiece) ||
            (currentPlayer == "black" && isWhitePiece)) {
            return false;
        }

        // Make the move
        board[toRow][toCol] = piece;
        board[fromRow][fromCol] = "";

        // Switch players
        currentPlayer = (currentPlayer == "white") ? "black" : "white";
        last_move_time_ = std::chrono::steady_clock::now(); // Reset timer for the next player
        first_move_made_ = true;
        return true;
    }

    void endGame(const std::string& winner, const std::string& reason) {
        gameActive = false;
        gameResult = winner + " wins by " + reason;
    }

    bool isActive() const { return gameActive; }
    std::string getCurrentPlayer() const { return currentPlayer; }
    bool isFirstMoveMade() const { return first_move_made_; }

    std::string toFen() const {
        std::string fen = "";
        int empty_squares = 0;
        for (int r = 0; r < 8; ++r) {
            for (int c = 0; c < 8; ++c) {
                std::string piece = board[r][c];
                if (piece.empty()) {
                    empty_squares++;
                } else {
                    if (empty_squares > 0) {
                        fen += std::to_string(empty_squares);
                        empty_squares = 0;
                    }
                    fen += piece;
                }
            }
            if (empty_squares > 0) {
                fen += std::to_string(empty_squares);
                empty_squares = 0;
            }
            if (r < 7) {
                fen += "/";
            }
        }

        // Add active color, castling availability, en passant target square,
        // halfmove clock, and fullmove number.
        // For simplicity, hardcoding these for now.
        // In a real game, these would need to be dynamically updated.
        fen += " " + currentPlayer.substr(0, 1); // 'w' or 'b'
        fen += " KQkq - 0 1"; // Default castling, no en passant, 0 halfmove, 1 fullmove
        return fen;
    }

    // New tick method for clock management
    bool tick() {
        if (!gameActive) return false;

        auto now = std::chrono::steady_clock::now();
        std::chrono::duration<float> elapsed_seconds = now - last_move_time_;
        last_move_time_ = now; // Update last move time for the next tick

        if (currentPlayer == "white") {
            white_time_seconds_ -= elapsed_seconds.count();
            if (white_time_seconds_ <= 0) {
                white_time_seconds_ = 0;
                gameActive = false; // Game over on timeout
                gameResult = "black wins by timeout";
                return true; // Timed out
            }
        } else { // currentPlayer == "black"
            black_time_seconds_ -= elapsed_seconds.count();
            if (black_time_seconds_ <= 0) {
                black_time_seconds_ = 0;
                gameActive = false; // Game over on timeout
                gameResult = "white wins by timeout";
                return true; // Timed out
            }
        }
        return false; // Not timed out
    }
};

// Forward declaration
class ChessSession;

class ChessServer : public std::enable_shared_from_this<ChessServer> {
private:
    net::io_context& ioc_;
    std::map<std::string, std::shared_ptr<ChessGame>> games_;
    std::vector<std::shared_ptr<ChessSession>> sessions_;
    mutable std::mutex sessions_mutex_;
    unsigned int next_game_id_;
    std::map<std::string, std::unique_ptr<net::steady_timer>> game_timers_;
    std::mutex game_timers_mutex_;

public:
    ChessServer(net::io_context& ioc) : ioc_(ioc), next_game_id_(0) {}

    void addSession(std::shared_ptr<ChessSession> session);
    void createGame(std::shared_ptr<ChessSession> session);
    void joinGame(std::shared_ptr<ChessSession> session, const std::string& game_id);
    void broadcastLobbyUpdate();
    void removeSession(std::shared_ptr<ChessSession> session);
    void broadcastMessage(const std::string& message, const std::string& game_id = "", std::shared_ptr<ChessSession> exclude = nullptr);
    std::shared_ptr<ChessGame> getGame(const std::string& game_id);
    size_t getSessionCount() const;
    std::string assignPlayerColor(std::shared_ptr<ChessSession> session);

    void startClockForGame(const std::string& game_id);
    void stopClockForGame(const std::string& game_id);
    void handleClockTick(const std::string& game_id, const boost::system::error_code& ec);
};

class ChessSession : public std::enable_shared_from_this<ChessSession> {
private:
    websocket::stream<beast::tcp_stream> ws_;
    beast::flat_buffer buffer_;
    std::shared_ptr<ChessServer> server_;
    std::string playerColor_;
    std::string game_id_;
    std::atomic<bool> is_closing_{ false };
    std::mutex send_mutex_;
    std::queue<std::string> send_queue_;
    std::atomic<bool> is_writing_{ false };

public:
    ChessSession(tcp::socket&& socket, std::shared_ptr<ChessServer> server)
        : ws_(std::move(socket)), server_(server) {}

    ~ChessSession() {
        std::cout << "ChessSession destroyed for game " << game_id_ << std::endl;
    }

    void run() {
        try {
            net::dispatch(ws_.get_executor(),
                [self = shared_from_this()]() {
                    self->on_run();
            });
        }
        catch (const std::exception& e) {
            std::cerr << "Exception in run: " << e.what() << std::endl;
            is_closing_.store(true);
        }
    }

    void send(const std::string& message) {
        try {
            if (is_closing_.load()) {
                std::cout << "Session " << game_id_ << " is closing, skipping send (message: " << message.substr(0, 50) << "...)" << std::endl;
                return;
            }

            std::lock_guard<std::mutex> guard(send_mutex_);

            if (is_closing_.load()) {
                std::cout << "Session " << game_id_ << " is closing (after lock), skipping send (message: " << message.substr(0, 50) << "...)" << std::endl;
                return;
            }

            // Add message to queue
            send_queue_.push(message);

            // Start writing if not already writing
            if (!is_writing_.exchange(true)) {
                // Using shared_from_this() directly creates a strong reference.
                net::dispatch(ws_.get_executor(),
                    [self = shared_from_this()]() {
                        self->do_write();
                });
            }
        }
        catch (const std::exception& e) {
            std::cerr << "Exception in send: " << e.what() << std::endl;
            is_closing_.store(true);
        }
    }

    const std::string& getPlayerColor() const { return playerColor_; }
    void setPlayerColor(const std::string& color) { playerColor_ = color; }

    const std::string& getGameId() const { return game_id_; }
    void setGameId(const std::string& id) { game_id_ = id; }

    auto get_executor() { return ws_.get_executor(); }

    bool isClosing() const { return is_closing_.load(); }

private:
    void on_run() {
        try {
            // Set suggested timeout settings for the websocket
            ws_.set_option(websocket::stream_base::timeout::suggested(beast::role_type::server));

            // Set a decorator to change the Server of the handshake
            ws_.set_option(websocket::stream_base::decorator([](websocket::response_type& res) {
                res.set(http::field::server, std::string(BOOST_BEAST_VERSION_STRING) + " chess-server");
                }));

            // Accept the websocket handshake
            ws_.async_accept(
                [self = shared_from_this()](beast::error_code ec) {
                    self->on_accept(ec);
            });
        }
        catch (const std::exception& e) {
            std::cerr << "Exception in on_run: " << e.what() << std::endl;
            is_closing_.store(true);
        }
    }

    void do_write() {
            // Ambil pesan pertama dari antrean
            std::string const& message = send_queue_.front();

            // Mulai operasi tulis asinkron
            // boost::beast::async_write akan mengirim pesan dan memanggil on_write setelah selesai
            ws_.async_write(net::buffer(message),
                [self = shared_from_this()](beast::error_code ec, std::size_t bytes_transferred) {
                    self->on_write(ec, bytes_transferred);
            });
    }

    void on_accept(beast::error_code ec) {
        try {
            if (ec) return fail(ec, "accept");
            std::cout << "WebSocket accepted successfully" << std::endl;

            // Add this session to the server
            server_->addSession(shared_from_this());

            // Read a message
            do_read();
        }
        catch (const std::exception& e) {
            std::cerr << "Exception in on_accept: " << e.what() << std::endl;
            is_closing_.store(true);
        }
    }

    void do_read() {
        try {
            if (is_closing_.load()) return;

            // Check if websocket is still open
            if (!ws_.is_open()) {
                is_closing_.store(true);
                return;
            }

            // Read a message into our buffer
            ws_.async_read(buffer_,
                [self = shared_from_this()](beast::error_code ec, std::size_t bytes_transferred) {
                    self->on_read(ec, bytes_transferred);
            });
        }
        catch (const std::exception& e) {
            std::cerr << "Exception in do_read: " << e.what() << std::endl;
            is_closing_.store(true);
        }
    }

    void on_read(beast::error_code ec, std::size_t bytes_transferred) {
        boost::ignore_unused(bytes_transferred);

        // This indicates that the session was closed for any reason
        if(ec) {
            // This is a normal disconnect, not an error to log.
            // Just remove the session from the server.
            return server_->removeSession(shared_from_this());
        }

        // Process the message
        try {
            std::string message = beast::buffers_to_string(buffer_.data());
            handleMessage(message);
        }
        catch (const std::exception& e) {
            std::cerr << "Exception in handleMessage: " << e.what() << std::endl;
            // If handling the message fails, we should probably disconnect the client
            return server_->removeSession(shared_from_this());
        }

        // Clear the buffer
        buffer_.consume(buffer_.size());

        // Read another message
        do_read();
    }

    void on_write(beast::error_code ec, std::size_t bytes_transferred) {
            // Pastikan flag `is_writing_` direset, karena operasi tulis telah selesai.
            is_writing_.store(false);

            // Cek apakah ada error saat operasi tulis.
            if (ec) {
                std::cerr << "WebSocket write error for session " << game_id_ << ": " << ec.message() << std::endl;
                if (ec != websocket::error::closed) {
                    is_closing_.store(true);
                    std::cout << "Session " << game_id_ << " marked as closing due to write error." << std::endl;
                }
                return;
            }

            // Jika tidak ada error, hapus pesan yang baru saja terkirim dari antrean.
            std::lock_guard<std::mutex> guard(send_mutex_);
            send_queue_.pop();

            // Periksa apakah antrean masih memiliki pesan dan sesi masih aktif.
            if (!send_queue_.empty() && !is_closing_.load()) {
                // Jika ada, setel flag `is_writing_` lagi dan panggil `do_write` untuk mengirim pesan berikutnya.
                is_writing_.store(true);
                net::dispatch(ws_.get_executor(),
                    [self = shared_from_this()]() {
                        self->do_write();
                });
            }
    }

    void handleMessage(const std::string& message) {
        if (is_closing_.load()) return;

        try {
            json data = json::parse(message);

            if (!data.contains("type") || !data["type"].is_string()) {
                json error;
                error["type"] = "error";
                error["message"] = "Invalid message format: missing or invalid type field";
                send(error.dump());
                return;
            }

            std::string type = data["type"];

            if (type == "createGame") {
                server_->createGame(shared_from_this());
            }
            else if (type == "joinGame") {
                if (!data.contains("gameId") || !data["gameId"].is_string()) {
                    json error;
                    error["type"] = "error";
                    error["message"] = "Invalid joinGame message: missing or invalid gameId field";
                    send(error.dump());
                    return;
                }
                std::string gameId = data["gameId"];
                server_->joinGame(shared_from_this(), gameId);
            }
            else if (type == "move") {
                std::shared_ptr<ChessGame> game = server_->getGame(game_id_);
                if (!game) {
                    json error;
                    error["type"] = "error";
                    error["message"] = "Game not found for this session";
                    send(error.dump());
                    return;
                }

                if (game->getCurrentPlayer() != playerColor_) {
                    json error;
                    error["type"] = "error";
                    error["message"] = "Not your turn";
                    send(error.dump());
                    return;
                }

                if (!data.contains("fromRow") || !data.contains("fromCol") ||
                    !data.contains("toRow") || !data.contains("toCol") ||
                    !data["fromRow"].is_number_integer() || !data["fromCol"].is_number_integer() ||
                    !data["toRow"].is_number_integer() || !data["toCol"].is_number_integer()) {
                    json error;
                    error["type"] = "error";
                    error["message"] = "Invalid move data";
                    send(error.dump());
                    return;
                }

                int fromRow = data["fromRow"];
                int fromCol = data["fromCol"];
                int toRow = data["toRow"];
                int toCol = data["toCol"];

                if (game->makeMove(fromRow, fromCol, toRow, toCol)) {
                    // If it's the first move, start the clock
                    if (game->isFirstMoveMade()) {
                        server_->startClockForGame(game_id_);
                    }

                    json moveResponse;
                    moveResponse["type"] = "boardUpdate";
                    moveResponse["gameState"] = game->getBoardState();
                    moveResponse["lastMove"] = {
                        {"fromRow", fromRow},
                        {"fromCol", fromCol},
                        {"toRow", toRow},
                        {"toCol", toCol}
                    };
                    server_->broadcastMessage(moveResponse.dump(), game_id_);
                }
                else {
                    json error;
                    error["type"] = "error";
                    error["message"] = "Invalid move";
                    send(error.dump());
                }
            }
            else if (type == "resign") {
                std::shared_ptr<ChessGame> game = server_->getGame(game_id_);
                if (!game) { /* ... error handling ... */ return; }
                std::string winner = (playerColor_ == "white") ? "black" : "white";
                game->endGame(winner, "resignation");

                json gameEnd;
                gameEnd["type"] = "gameEnded";
                gameEnd["reason"] = "resignation";
                gameEnd["winner"] = winner;
                gameEnd["resignedPlayer"] = playerColor_;
                server_->broadcastMessage(gameEnd.dump(), game_id_);
                server_->stopClockForGame(game_id_);
            }
            else if (type == "newGame") {
                std::shared_ptr<ChessGame> game = server_->getGame(game_id_);
                if (!game) { /* ... error handling ... */ return; }
                game->resetBoard();

                json newGameResponse;
                newGameResponse["type"] = "newGame";
                newGameResponse["gameState"] = game->getBoardState();
                server_->broadcastMessage(newGameResponse.dump(), game_id_);
                server_->stopClockForGame(game_id_);
            }
            else {
                json error;
                error["type"] = "error";
                error["message"] = "Unknown message type: " + type;
                send(error.dump());
            }
        }
        catch (const std::exception& e) {
            std::cerr << "Error processing message: " << e.what() << std::endl;
            json error;
            error["type"] = "error";
            error["message"] = "Server error processing message";
            send(error.dump());
        }
    }

    void fail(beast::error_code ec, char const* what) {
        // Only log if not a normal close
        if (ec != websocket::error::closed && ec != net::error::eof) {
            std::cerr << what << ": " << ec.message() << "\n";
        }
        is_closing_.store(true);
    }
};

// ChessServer implementation
void ChessServer::addSession(std::shared_ptr<ChessSession> session) {
    try {
        std::cout << "[addSession] New session added to server." << std::endl;
        {
            std::lock_guard<std::mutex> guard(sessions_mutex_);
            sessions_.push_back(session);
        }
        // When a new user connects, send them the list of available games.
        // Delaying broadcastLobbyUpdate for debugging connection stability
        // When a new user connects, send them the list of available games.
        // Delaying broadcastLobbyUpdate for debugging connection stability
        // Using shared_from_this() directly creates a strong reference, ensuring the server
        // remains alive as long as the timer's lambda is pending or executing.
        // This removes the weak_ptr as requested.
        net::post(ioc_, [self = shared_from_this()]() {
            auto timer = std::make_shared<net::steady_timer>(self->ioc_);
            timer->expires_at(std::chrono::steady_clock::now() + std::chrono::milliseconds(500));
            timer->async_wait([self, timer](const boost::system::error_code& ec) {
                if (!ec) {
                    self->broadcastLobbyUpdate();
                }
            });
        });
    }
    catch (const std::exception& e) {
        std::cerr << "Exception in addSession: " << e.what() << std::endl;
    }
}

void ChessServer::removeSession(std::shared_ptr<ChessSession> session) {
    try {
        std::cout << "[removeSession] Starting removal for a session." << std::endl;
        std::string game_id_to_notify;
        std::string disconnected_color;
        json gameEnd_message;

        {
            std::lock_guard<std::mutex> guard(sessions_mutex_);
            std::cout << "[removeSession] Mutex locked." << std::endl;

            auto it = sessions_.begin();
            while (it != sessions_.end()) {
                if (*it == session) {
                    game_id_to_notify = (*it)->getGameId();
                    disconnected_color = (*it)->getPlayerColor();
                    std::cout << "[removeSession] Player " << disconnected_color << " from game " << game_id_to_notify << " disconnected." << std::endl;
                    it = sessions_.erase(it);
                    std::cout << "[removeSession] Session erased from list." << std::endl;
                    break;
                } else {
                    ++it;
                }
            }

            if (!game_id_to_notify.empty()) {
                std::cout << "[removeSession] Player was in game " << game_id_to_notify << ". Processing game end." << std::endl;
                auto game_it = games_.find(game_id_to_notify);
                if (game_it != games_.end()) {
                    std::cout << "[removeSession] Game found in map." << std::endl;
                    auto game = game_it->second;
                    if (game->isActive()) {
                        std::cout << "[removeSession] Game is active. Ending it." << std::endl;
                        std::string winner = (disconnected_color == "white") ? "black" : "white";
                        game->endGame(winner, "disconnect");

                        gameEnd_message["type"] = "gameEnded";
                        gameEnd_message["reason"] = "disconnect";
                        gameEnd_message["winner"] = winner;
                        gameEnd_message["disconnectedPlayer"] = disconnected_color;
                        std::cout << "[removeSession] gameEnd message prepared: " << gameEnd_message.dump() << std::endl;
                    } else {
                        std::cout << "[removeSession] Game was already inactive." << std::endl;
                    }
                    // Clean up the game if it's over
                    games_.erase(game_it);
                    stopClockForGame(game_id_to_notify);
                    std::cout << "[removeSession] Game " << game_id_to_notify << " has been removed from map." << std::endl;
                }
                 else {
                    std::cout << "[removeSession] Game " << game_id_to_notify << " not found in map." << std::endl;
                }
            }
             else {
                std::cout << "[removeSession] Disconnected session was not in a game." << std::endl;
            }
        } // Mutex is unlocked here
        std::cout << "[removeSession] Mutex unlocked." << std::endl;

        // Broadcast the message outside the lock to prevent deadlock
        if (!gameEnd_message.is_null()) {
            std::cout << "[removeSession] Broadcasting gameEnd message to game " << game_id_to_notify << std::endl;
            broadcastMessage(gameEnd_message.dump(), game_id_to_notify);
        }
         else {
            std::cout << "[removeSession] No gameEnd message to broadcast." << std::endl;
        }

        std::cout << "[removeSession] Broadcasting lobby update." << std::endl;
        broadcastLobbyUpdate();
    }
    catch (const std::exception& e) {
        std::cerr << "Exception in removeSession: " << e.what() << std::endl;
    }
}

void ChessServer::createGame(std::shared_ptr<ChessSession> session) {
    json playerAssigned_msg;
    json boardUpdate_msg;

    { // New scope for the lock
        std::lock_guard<std::mutex> guard(sessions_mutex_);

        std::string game_id = "game_" + std::to_string(next_game_id_++);
        auto game = std::make_shared<ChessGame>();
        games_[game_id] = game;

        session->setGameId(game_id);
        session->setPlayerColor("white");

        std::cout << "Player created and joined game " << game_id << " as white." << std::endl;

        // Prepare messages
        playerAssigned_msg["type"] = "playerAssigned";
        playerAssigned_msg["color"] = "white";
        playerAssigned_msg["gameId"] = game_id;

        boardUpdate_msg["type"] = "boardUpdate";
        boardUpdate_msg["gameState"] = game->getBoardState();
    } // Mutex is unlocked here

    // Send messages outside the lock
    net::post(session->get_executor(), [session, msg = playerAssigned_msg.dump()]() { session->send(msg); });
    net::post(session->get_executor(), [session, msg = boardUpdate_msg.dump()]() { session->send(msg); });

    // Delay broadcast to ensure session state is updated
    net::post(ioc_, [self = shared_from_this()]() {
        auto timer = std::make_shared<net::steady_timer>(self->ioc_);
        timer->expires_at(std::chrono::steady_clock::now() + std::chrono::milliseconds(100)); // Small delay
        timer->async_wait([self, timer](const boost::system::error_code& ec) {
            if (!ec) {
                self->broadcastLobbyUpdate();
            }
        });
    });
}

void ChessServer::joinGame(std::shared_ptr<ChessSession> session, const std::string& game_id) {
    json playerAssigned_msg;
    json boardUpdate_msg;
    json gameStart_msg;
    bool game_started = false;

    { // New scope for the lock
        std::lock_guard<std::mutex> guard(sessions_mutex_);

        auto game_it = games_.find(game_id);
        if (game_it == games_.end()) {
            json error;
            error["type"] = "error";
            error["message"] = "Game not found: " + game_id;
            net::post(session->get_executor(), [session, msg = error.dump()]() { session->send(msg); });
            return;
        }
        auto game = game_it->second;

        int players_in_game = 0;
        for (const auto& s : sessions_) {
            if (s->getGameId() == game_id) {
                players_in_game++;
            }
        }

        if (players_in_game >= 2) {
            json error;
            error["type"] = "error";
            error["message"] = "Game is full: " + game_id;
            net::post(session->get_executor(), [session, msg = error.dump()]() { session->send(msg); });
            return;
        }

        session->setGameId(game_id);
        session->setPlayerColor("black");

        std::cout << "Player joined game " << game_id << " as black." << std::endl;

        // Prepare messages
        playerAssigned_msg["type"] = "playerAssigned";
        playerAssigned_msg["color"] = "black";
        playerAssigned_msg["gameId"] = game_id;

        boardUpdate_msg["type"] = "boardUpdate";
        boardUpdate_msg["gameState"] = game->getBoardState();

        game_started = true;
        gameStart_msg["type"] = "gameStart";
        gameStart_msg["message"] = "Game starting with 2 players!";
        gameStart_msg["gameId"] = game_id;
    } // Mutex is unlocked here

    // Send messages outside the lock
    net::post(session->get_executor(), [session, msg = playerAssigned_msg.dump()]() { session->send(msg); });
    net::post(session->get_executor(), [session, msg = boardUpdate_msg.dump()]() { session->send(msg); });

    if (game_started) {
        broadcastMessage(gameStart_msg.dump(), game_id);
        // Delay broadcast to ensure session state is updated
        net::post(ioc_, [self = shared_from_this()]() {
            auto timer = std::make_shared<net::steady_timer>(self->ioc_);
            timer->expires_at(std::chrono::steady_clock::now() + std::chrono::milliseconds(100)); // Small delay
            timer->async_wait([self, timer](const boost::system::error_code& ec) {
                if (!ec) {
                    self->broadcastLobbyUpdate();
                }
            });
        });
    }
}

void ChessServer::broadcastLobbyUpdate() {
    std::vector<std::string> waiting_games;
    {
        std::lock_guard<std::mutex> guard(sessions_mutex_);
        for (const auto& pair : games_) {
            std::string game_id = pair.first;
            int players_in_game = 0;
            for (const auto& s : sessions_) {
                if (s->getGameId() == game_id) {
                    players_in_game++;
                }
            }
            if (players_in_game == 1) {
                waiting_games.push_back(game_id);
            }
        }
    }

    json lobbyUpdate_msg;
    lobbyUpdate_msg["type"] = "lobbyUpdate";
    lobbyUpdate_msg["games"] = waiting_games;

    std::cout << "[broadcastLobbyUpdate] Sending lobby update with games: ";
    for (const auto& game_id : waiting_games) {
        std::cout << game_id << " ";
    }
    std::cout << std::endl;

    // Broadcast to lobby (sessions with no game_id)
    std::vector<std::shared_ptr<ChessSession>> lobby_sessions;
    {
        std::lock_guard<std::mutex> guard(sessions_mutex_);
        for (const auto& session : sessions_) {
            if (session && !session->isClosing() && session->getGameId().empty()) {
                lobby_sessions.push_back(session);
            }
        }
    }

    for (const auto& session : lobby_sessions) {
        net::post(session->get_executor(), [session, msg = lobbyUpdate_msg.dump()]() {
            session->send(msg);
        });
    }
}

void ChessServer::broadcastMessage(const std::string& message, const std::string& game_id, std::shared_ptr<ChessSession> exclude) {
    std::vector<std::shared_ptr<ChessSession>> sessions_to_send;
    {
        std::lock_guard<std::mutex> guard(sessions_mutex_);
        for (const auto& session : sessions_) {
            if (session && !session->isClosing() && (game_id.empty() || session->getGameId() == game_id)) {
                if (session != exclude) {
                    sessions_to_send.push_back(session);
                }
            }
        }
    }

    std::cout << "Broadcasting message to " << sessions_to_send.size() << " sessions (game_id: " << (game_id.empty() ? "all" : game_id) << "): " << message << std::endl;

    for (const auto& session : sessions_to_send) {
        // Post the send operation to the session's strand
        net::post(session->get_executor(), [session, message]() {
            session->send(message);
        });
    }
}

size_t ChessServer::getSessionCount() const {
    std::lock_guard<std::mutex> guard(sessions_mutex_);
    return sessions_.size();
}

std::shared_ptr<ChessGame> ChessServer::getGame(const std::string& game_id) {
    std::lock_guard<std::mutex> guard(sessions_mutex_); // Protect access to games_ map
    auto it = games_.find(game_id);
    if (it != games_.end()) {
        return it->second;
    }
    return nullptr; // Game not found
}

void ChessServer::startClockForGame(const std::string& game_id) {
    std::lock_guard<std::mutex> guard(game_timers_mutex_);
    if (game_timers_.find(game_id) == game_timers_.end()) {
        auto timer = std::make_unique<net::steady_timer>(ioc_);
        timer->expires_at(std::chrono::steady_clock::now() + std::chrono::milliseconds(100)); // Tick every 100ms
        timer->async_wait(
            [self = this->shared_from_this(), game_id](beast::error_code ec) {
                self->handleClockTick(game_id, ec);
        });
        game_timers_[game_id] = std::move(timer);
    }
}

void ChessServer::stopClockForGame(const std::string& game_id) {
    std::lock_guard<std::mutex> guard(game_timers_mutex_);
    auto it = game_timers_.find(game_id);
    if (it != game_timers_.end()) {
        it->second->cancel();
        game_timers_.erase(it);
        std::cout << "[stopClockForGame] Clock stopped for game " << game_id << std::endl;
    }
}

void ChessServer::handleClockTick(const std::string& game_id, const boost::system::error_code& ec) {
    if (ec == boost::asio::error::operation_aborted) {
        // Timer was cancelled, game ended or session closed
        return;
    }

    std::shared_ptr<ChessGame> game = getGame(game_id);
    if (!game || !game->isActive()) {
        std::cout << "[handleClockTick] Game " << game_id << " is no longer active or found. Stopping clock." << std::endl;
        stopClockForGame(game_id);
        return;
    }

    bool timed_out = game->tick();

    json boardUpdate_msg;
    boardUpdate_msg["type"] = "boardUpdate";
    boardUpdate_msg["gameState"] = game->getBoardState();

    broadcastMessage(boardUpdate_msg.dump(), game_id);

    if (timed_out) {
        json gameEnd;
        gameEnd["type"] = "gameEnded";
        gameEnd["reason"] = "timeout";
        gameEnd["winner"] = game->getCurrentPlayer() == "white" ? "black" : "white"; // The other player wins
        broadcastMessage(gameEnd.dump(), game_id);
        stopClockForGame(game_id);
    } else {
        // Reschedule the timer for the next tick
        std::lock_guard<std::mutex> guard(game_timers_mutex_);
        auto it = game_timers_.find(game_id);
        if (it != game_timers_.end()) {
            it->second->expires_at(std::chrono::steady_clock::now() + std::chrono::milliseconds(100));
            it->second->async_wait(beast::bind_front_handler(&ChessServer::handleClockTick, this->shared_from_this(), game_id));
        }
    }
}

// Accepts incoming connections and launches the sessions
class Listener : public std::enable_shared_from_this<Listener> {
private:
    net::io_context& ioc_;
    tcp::acceptor acceptor_;
    std::shared_ptr<ChessServer> server_;

public:
    Listener(net::io_context& ioc, tcp::endpoint endpoint, std::shared_ptr<ChessServer> server)
        : ioc_(ioc), acceptor_(net::make_strand(ioc)), server_(server) {
        beast::error_code ec;

        // Open the acceptor
        acceptor_.open(endpoint.protocol(), ec);
        if (ec) {
            fail(ec, "open");
            return;
        }

        // Allow address reuse
        acceptor_.set_option(net::socket_base::reuse_address(true), ec);
        if (ec) {
            fail(ec, "set_option");
            return;
        }

        // Bind to the server address
        acceptor_.bind(endpoint, ec);
        if (ec) {
            fail(ec, "bind");
            return;
        }

        // Start listening for connections
        acceptor_.listen(net::socket_base::max_listen_connections, ec);
        if (ec) {
            fail(ec, "listen");
            return;
        }
    }

    void run() {
        do_accept();
    }

private:
    void do_accept() {
        // The new connection gets its own strand
        acceptor_.async_accept(net::make_strand(ioc_),
            beast::bind_front_handler(&Listener::on_accept, shared_from_this()));
    }

    void on_accept(beast::error_code ec, tcp::socket socket) {
        if (ec) {
            fail(ec, "accept");
        }
        else {
            // Create the session
            auto session = std::make_shared<ChessSession>(std::move(socket), server_);
            // Add this session to the server's list of active sessions
            server_->addSession(session);
            // Run the session
            session->run();
        }

        // Accept another connection
        do_accept();
    }

    void fail(beast::error_code ec, char const* what) {
        std::cerr << what << ": " << ec.message() << "\n";
    }
};

int main(int argc, char* argv[]) {
    try {
        auto const address = net::ip::make_address("0.0.0.0");
        auto const port = static_cast<unsigned short>(8080);
        auto const threads = std::max<int>(1, 4);

        // The io_context is required for all I/O
        net::io_context ioc{ threads };

        // Create the chess server
        auto server = std::make_shared<ChessServer>(ioc);

        // Create and launch a listening port
        auto listener = std::make_shared<Listener>(ioc, tcp::endpoint{ address, port }, server);
        listener->run();

        std::cout << "Chess WebSocket Server started on port " << port << std::endl;
        std::cout << "Connect with WebSocket client to ws://localhost:" << port << std::endl;

        // Run the I/O service on the requested number of threads
        std::vector<std::thread> v;
        v.reserve(threads - 1);
        for (auto i = threads - 1; i > 0; --i) {
            v.emplace_back([&ioc] {
                try {
                    ioc.run();
                }
                catch (const std::exception& e) {
                    std::cerr << "Exception in worker thread: " << e.what() << std::endl;
                }
                });
        }

        try {
            ioc.run();
        }
        catch (const std::exception& e) {
            std::cerr << "Exception in main thread: " << e.what() << std::endl;
        }

        // Wait for all threads to complete
        for (auto& t : v) {
            if (t.joinable()) {
                t.join();
            }
        }

    }
    catch (const std::exception& e) {
        std::cerr << "Fatal exception in main: " << e.what() << std::endl;
        return EXIT_FAILURE;
    }

    return EXIT_SUCCESS;
}