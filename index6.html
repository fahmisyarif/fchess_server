<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FChess Game</title>
    <link rel="stylesheet" href="chessboard-1.0.0.min.css">
    <style>
        body { font-family: Arial, sans-serif; background-color: #f5f5f5; margin: 0; padding: 20px; }
        .game-container { max-width: 500px; margin: 0 auto; background-color: white; border-radius: 10px; padding: 20px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); }
        h1 { text-align: center; color: #333; }
        #myBoard { margin: 0 auto; }
        .status-container { text-align: center; margin-top: 20px; }
        #status, #playerDisplay { font-size: 1.1em; font-weight: bold; color: #555; padding: 10px; background-color: #f8f9fa; border-radius: 5px; min-height: 20px; }
        .controls { text-align: center; margin: 20px 0; }
        .btn { padding: 10px 20px; margin: 0 10px; border: none; border-radius: 5px; cursor: pointer; font-size: 16px; color: white; }
        .btn:hover { opacity: 0.9; }
        .btn:disabled { background-color: #6c757d; cursor: not-allowed; }
        .btn-danger { background-color: #dc3545; }
        .btn-success { background-color: #28a745; }
        .connection-status { display: inline-block; width: 12px; height: 12px; border-radius: 50%; margin-right: 8px; vertical-align: middle; }
        .connected { background-color: #28a745; }
        .disconnected { background-color: #dc3545; }
        .waiting { background-color: #ffc107; }
    </style>
</head>
<body>
    <div id="lobby" class="game-container" style="display: none;">
        <h2>Lobby</h2>
        <div class="controls">
            <button id="createGameBtn" class="btn btn-success">Create New Game</button>
        </div>
        <hr>
        <h4>Or Join an Existing Game:</h4>
        <div id="gameList" class="controls">
            <!-- Waiting games will be listed here -->
        </div>
        <hr>
        <div class="controls">
            <input type="text" id="joinGameId" placeholder="Enter Game ID">
            <button id="joinGameBtn" class="btn" disabled>Join Game</button>
        </div>
    </div>
    <div class="game-container">
        <h1>♔ FChess Game ♚</h1>
        <div class="status-container">
            <div id="playerDisplay"><span class="connection-status disconnected"></span>Player: Not connected</div>
            <div id="status" style="margin-top: 10px;">Connecting to server...</div>
        </div>

        <!-- Add clock display here -->
        <div class="clock-container" style="display: flex; justify-content: space-around; margin-bottom: 10px;">
            <div id="whiteClock" style="font-size: 1.5em; font-weight: bold; color: #000;">White: 05:00</div>
            <div id="blackClock" style="font-size: 1.5em; font-weight: bold; color: #000;">Black: 05:00</div>
        </div>

        <div id="myBoard" style="width: 400px; margin-top: 20px;"></div>

        <div class="controls">
            <button id="resignBtn" class="btn btn-danger" disabled>Resign</button>
            <button id="newGameBtn" class="btn btn-success" disabled>New Game</button>
        </div>
    </div>

    <script src="jquery-3.5.1.min.js"></script>
    <script src="chessboard-1.0.0.min.js"></script>
    <script src="chess.js"></script>
    <script>
        // --- Global State ---
        let board = null;
        let game = new Chess();
        let socket;
        let playerColor = null;
        let gameActive = false;
        let myGameId = null;

        let whiteTimeRemaining = 0;
        let blackTimeRemaining = 0;
        let lastUpdateTime = 0;
        let clockInterval = null;

        // --- DOM Elements ---
        const statusEl = $('#status');
        const playerDisplayEl = $('#playerDisplay');
        const resignBtn = $('#resignBtn');
        const newGameBtn = $('#newGameBtn');
        const connectionIndicator = $('.connection-status');

        const whiteClockEl = $('#whiteClock');
        const blackClockEl = $('#blackClock');

        const lobbyEl = $('#lobby');
        const gameContainerEl = $('.game-container').not('#lobby');
        const createGameBtn = $('#createGameBtn');
        const joinGameBtn = $('#joinGameBtn');
        const joinGameIdInput = $('#joinGameId');

        // --- WebSocket Logic ---
        function connectToServer() {
            try {
                socket = new WebSocket('ws://localhost:8080');

                socket.onopen = () => {
                    console.log('Connected to server');
                    setStatus('Connected to server. Create or join a game.');
                    setConnectionStatus('connected');
                    lobbyEl.show();
                    gameContainerEl.hide();
                };

                socket.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        handleServerMessage(data);
                    } catch (e) {
                        console.error('Error parsing message:', e);
                    }
                };

                socket.onclose = () => {
                    console.log('Connection closed');
                    setStatus('Connection closed. Reconnecting...');
                    setConnectionStatus('disconnected');
                    gameActive = false;
                    updateButtonStates();
                    setTimeout(connectToServer, 3000); // Reconnect
                };

                socket.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    setStatus('Connection error.');
                    setConnectionStatus('disconnected');
                };
            } catch (e) {
                console.error('Failed to connect:', e);
                setStatus('Error connecting to server.');
            }
        }

        function handleServerMessage(data) {
            console.log('Received:', data);

            switch (data.type) {
                case 'playerAssigned':
                    lobbyEl.hide();
                    gameContainerEl.show();
                    playerColor = data.color;
                    myGameId = data.gameId;
                    board.orientation(playerColor);
                    setConnectionStatus('connected');
                    playerDisplayEl.html(`<span class="connection-status connected"></span>Player: ${capitalize(playerColor)} (Game: ${myGameId})`);
                    setStatus(`You are ${playerColor}. Waiting for opponent...`);
                    break;

                case 'lobbyUpdate':
                    const gameList = $('#gameList');
                    gameList.empty(); // Clear the list
                    if (data.games && data.games.length > 0) {
                        data.games.forEach(gameId => {
                            const gameBtn = $('<button class="btn">Join Game: ' + gameId + '</button>');
                            gameBtn.on('click', () => {
                                joinGameIdInput.val(gameId);
                                joinGameBtn.prop('disabled', false);
                            });
                            gameList.append(gameBtn);
                        });
                    } else {
                        gameList.html('<em>No games waiting for players.</em>');
                    }
                    break;

                case 'gameStart':
                    gameActive = true;
                    updateButtonStates();
                    setStatus('Game started! White to move.');
                    break;

                case 'boardUpdate':
                    updateGameState(data.gameState);
                    if (data.lastMove) {
                        highlightLastMove(data.lastMove);
                    }
                    break;

                case 'gameEnded':
                    gameActive = false;
                    updateButtonStates();
                    const winnerText = data.winner === playerColor ? 'You win!' : 'You lose!';
                    setStatus(`Game Over: ${winnerText} by ${data.reason}.`);
                    alert(`Game Over! ${winnerText}`);
                    break;
                
                case 'newGame':
                    game.reset();
                    board.position(game.fen());
                    gameActive = true;
                    updateButtonStates();
                    setStatus("New game started! White's turn.");
                    break;

                case 'playerDisconnected':
                    gameActive = false;
                    updateButtonStates();
                    setStatus('Opponent disconnected. Waiting...');
                    break;

                case 'error':
                    setStatus('Error: ' + data.message);
                    // If it's an invalid move error, snap the piece back
                    board.position(game.fen(), false);
                    break;
            }
        }

        // --- Game Logic & UI ---
        function updateGameState(gameState) {
            // The server's board representation is not a FEN string.
            // We must convert it to keep our client-side chess.js instance in sync.
            const fen = serverBoardToFen(gameState.board, gameState.currentPlayer);
            game.load(fen);
            board.position(fen);
            
            gameActive = gameState.gameActive;
            updateButtonStates();

            // Synchronize local clock with server time
            whiteTimeRemaining = gameState.whiteTime;
            blackTimeRemaining = gameState.blackTime;
            lastUpdateTime = performance.now(); // Reset last update time

            // Start/stop clock based on game state and game over status
            if (gameActive && !game.game_over()) { // Only start if game is active and not over
                startClock();
            } else {
                stopClock();
            }

            // Update clocks (initial display)
            updateClockDisplay(whiteClockEl, whiteTimeRemaining);
            updateClockDisplay(blackClockEl, blackTimeRemaining);

            if (!gameActive) {
                setStatus("Game is over.");
                return;
            }

            const turn = game.turn() === 'w' ? 'White' : 'Black';
            const statusText = playerColor.charAt(0) === game.turn() ? "Your turn" : `Waiting for ${turn}`;
            setStatus(`${statusText} (${turn} to move})`);
        }

        function onDragStart(source, piece) {
            // Prevent moves if the game is over or it's not your turn
            console.log('onDragStart called:', { source, piece, gameActive, gameOver: game.game_over(), playerColor, gameTurn: game.turn() });

            if (!gameActive) {
                console.log('Blocked: Game not active');
                return false;
            }
            if (game.game_over()) {
                console.log('Blocked: Game over');
                return false;
            }
            if (playerColor.charAt(0) !== game.turn()) {
                console.log('Blocked: Not your turn', { playerColor, gameTurn: game.turn() });
                return false;
            }
            if ((game.turn() === 'w' && piece.search(/^b/) !== -1)) {
                console.log('Blocked: White trying to move black piece');
                return false;
            }
            if ((game.turn() === 'b' && piece.search(/^w/) !== -1)) {
                console.log('Blocked: Black trying to move white piece');
                return false;
            }
            console.log('Drag allowed');
        }

        function onDrop(source, target) {
            // Attempt to make a move in the local chess.js instance
            const move = game.move({
                from: source,
                to: target,
                promotion: 'q' // Always promote to queen for simplicity
            });

            // If the move is illegal, snap the piece back
            if (move === null) return 'snapback';

            // If the move is legal locally, send it to the server for final validation
            const moveData = {
                type: 'move',
                gameId: myGameId, // Add gameId
                ...algebraicToRowCol(source), // fromRow, fromCol
                ...algebraicToRowCol(target, true) // toRow, toCol
            };
            
            console.log('Sending move:', moveData);
            socket.send(JSON.stringify(moveData));
        }
        
        function highlightLastMove(lastMove) {
            // Remove previous highlights
            $('#myBoard .square-55d63').css('background-color', '');
            
            const fromSquare = rowColToAlgebraic(lastMove.fromRow, lastMove.fromCol);
            const toSquare = rowColToAlgebraic(lastMove.toRow, lastMove.toCol);

            $('#myBoard .square-' + fromSquare).css('background', '#ffb347');
            $('#myBoard .square-' + toSquare).css('background', '#ffb347');
        }

        // --- Helper Functions ---
        function serverBoardToFen(boardData, currentPlayer) {
            // Converts the server's 2D array into a FEN string.
            // NOTE: This makes assumptions about castling, en passant, etc.,
            // as the server does not provide this information.
            let fen = boardData.map(row => {
                let empty = 0;
                let rowFen = '';
                row.forEach(piece => {
                    if (piece === '') {
                        empty++;
                    } else {
                        if (empty > 0) {
                            rowFen += empty;
                            empty = 0;
                        }
                        rowFen += piece;
                    }
                });
                if (empty > 0) rowFen += empty;
                return rowFen;
            }).join('/');

            const turn = currentPlayer === 'white' ? 'w' : 'b';
            // Assume default castling, no en passant, and move counters.
            fen += ` ${turn} KQkq - 0 1`;
            return fen;
        }

        function algebraicToRowCol(alg, isTarget = false) {
            const col = alg.charCodeAt(0) - 'a'.charCodeAt(0);
            const row = 8 - parseInt(alg.charAt(1), 10);
            if (isTarget) {
                return { toRow: row, toCol: col };
            }
            return { fromRow: row, fromCol: col };
        }
        
        function rowColToAlgebraic(row, col) {
            const file = String.fromCharCode('a'.charCodeAt(0) + col);
            const rank = 8 - row;
            return file + rank;
        }

        function setStatus(message) { statusEl.text(message); }
        function capitalize(s) { return s.charAt(0).toUpperCase() + s.slice(1); }
        function setConnectionStatus(status) { connectionIndicator.removeClass('connected waiting disconnected').addClass(status); }

        function updateButtonStates() {
            resignBtn.prop('disabled', !gameActive);
            newGameBtn.prop('disabled', false); // Can always offer a new game
        }

        // --- Clock Management ---
        function startClock() {
            if (clockInterval) {
                clearInterval(clockInterval);
            }
            clockInterval = setInterval(updateClock, 100); // Update every 100ms
        }

        function stopClock() {
            if (clockInterval) {
                clearInterval(clockInterval);
                clockInterval = null;
            }
        }

        function updateClock() {
            const now = performance.now();
            const elapsed = (now - lastUpdateTime) / 1000; // in seconds
            lastUpdateTime = now;

            if (gameActive && playerColor.charAt(0) === game.turn()) { // Only decrement if game is active and it's my turn
                if (game.turn() === 'w') {
                    whiteTimeRemaining -= elapsed;
                    if (whiteTimeRemaining < 0) whiteTimeRemaining = 0;
                } else {
                    blackTimeRemaining -= elapsed;
                    if (blackTimeRemaining < 0) blackTimeRemaining = 0;
                }
            }

            updateClockDisplay(whiteClockEl, whiteTimeRemaining);
            updateClockDisplay(blackClockEl, blackTimeRemaining);
        }

        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
        }

        function updateClockDisplay(element, seconds) {
            element.text(element.attr('id').includes('white') ? `White: ${formatTime(seconds)}` : `Black: ${formatTime(seconds)}`);
        }

        // --- Event Handlers ---
        resignBtn.on('click', () => {
            if (confirm('Are you sure you want to resign?')) {
                socket.send(JSON.stringify({ type: 'resign', gameId: myGameId }));
            }
        });

        newGameBtn.on('click', () => {
            socket.send(JSON.stringify({ type: 'newGame', gameId: myGameId }));
        });

        createGameBtn.on('click', () => {
            socket.send(JSON.stringify({ type: 'createGame' }));
        });

        joinGameBtn.on('click', () => {
            const gameId = joinGameIdInput.val();
            if (gameId) {
                socket.send(JSON.stringify({ type: 'joinGame', gameId: gameId }));
            }
        });

        joinGameIdInput.on('input', () => {
            joinGameBtn.prop('disabled', !joinGameIdInput.val());
        });

        // --- Initialization ---
        const config = {
            draggable: true,
            position: 'start',
            pieceTheme: 'img/chesspieces/wikipedia/{piece}.png',
            onDragStart: onDragStart,
            onDrop: onDrop,
        };
        board = Chessboard('myBoard', config);
        $(window).resize(board.resize);

        connectToServer();
    </script>
</body>
</html>
