Selalu guard JSON parsing dengan try/catch

void handleMessage(const std::string& message) {
    if (is_closing_.load()) return;
    try {
        json data = json::parse(message);
        ...
    } catch (const std::exception& e) {
        json error;
        error["type"] = "error";
        error["message"] = std::string("JSON parse/logic error: ") + e.what();
        send(error.dump());
        return;
    }
}


Dengan begitu, JSON yang aneh tidak pernah bisa keluar ke main.

Jangan pakai shared_from_this() sembarangan

Di tempat-tempat rawan (misalnya dalam fail() atau send()), bisa cek dulu dengan weak_from_this() lalu lock.

Kalau lock() gagal → berarti objek sudah mau hilang, jangan lanjut.

if (auto self = weak_from_this().lock()) {
    net::dispatch(ws_.get_executor(),
        beast::bind_front_handler(&ChessSession::do_write, self));
}


Tangkap semua exception di callback asinkron
Misalnya di on_read, on_write, do_accept, do_write, dll.
Sekarang sebagian sudah ada try/catch, tapi belum di semua tempat. Idealnya setiap callback lambdas / handler punya try/catch supaya exception tidak pernah naik ke ioc.run().

Fail-safe di thread worker juga
Kamu sudah kasih try/catch di thread pool worker ("Exception in worker thread: ...") → bagus.
Tapi di main thread ioc.run() juga sebaiknya diberi loop, supaya kalau run() terhenti, server tetap hidup:

while (true) {
    try {
        ioc.run();
        break; // normal exit
    } catch (const std::exception& e) {
        std::cerr << "Exception in main io_context: " << e.what() << std::endl;
    }
}